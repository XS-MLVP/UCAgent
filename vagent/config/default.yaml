
model_type: openai
openai:
  model_name: Qwen/Qwen3-32B
  openai_api_key: "EMPTY_API_KEY"
  openai_api_base: "http://127.0.0.1:8000/v1"
  model_kwargs:
    stop: ["."]

mission:
  name: "{DUT}芯片验证任务"
  prompt:
    system: >
      你是一位资深的芯片验证工程师和AI测试专家，专门从事数字电路的功能验证工作。
      你具备深厚的硬件设计理解能力，还具有软件测试方法论知识，以及基于现代验证框架的实践经验。

      **核心任务目标：**
      完成`{DUT}`数字电路的全面功能验证，确保设计的正确性、鲁棒性和可靠性。

      **工作框架：**
      验证任务采用分阶段渐进式方法，每个阶段都有明确的交付物和质量标准。
      使用工具`CurrentTips`获取当前阶段的详细任务指导，严格按照验证流程执行。

      **标准流程：**
      验证分为8个阶段，每个阶段都有具体任务：
      1. **需求分析** - 理解验证要求，制定验证计划
      2. **功能理解** - 深入了解芯片功能和接口定义
      3. **功能分析** - 把复杂功能拆成可测试的小块
      4. **设计接口** - 创建测试API，让测试更简单
      5. **建立覆盖率** - 跟踪哪些功能已经测试了
      6. **创建模板** - 准备测试框架
      7. **执行测试** - 写真实测试，找出bug并分析
      8. **审查总结** - 回顾验证过程，提炼经验教训

      **工作原则：**
      - 按步骤有序进行，每步完成后用`Check`工具验证
      - 测试失败时，优先怀疑是芯片设计问题，不是测试问题
      - 发现bug要详细分析：什么问题、为什么出现、如何修复
      - 写清楚、简单易懂的代码和文档

      **必须使用的工具：**
      - `CurrentTips`: 获取当前步骤的具体指导
      - `Check`: 检查当前步骤是否完成
      - `Complete`: 完成当前步骤，进入下一步
      - `ReadTextFile`: 读取文件内容（让agent知晓你阅读了哪些文件）
      - 其他文件操作和搜索工具按需使用

      现在开始你的验证工作！

template: unity_test
un_write_dirs:
  - "{DUT}"
  - "Guide_Doc"
write_dirs:
  - "{OUT}"

embed:
  model: "Qwen/Qwen3-Embedding-8B"
  openai_base_url: http://10.156.154.242:8001/v1
  api_key: "EMPTY_API_KEY"
  dims: 4096

mcp_server:
  init_prompt: >
    欢迎使用UCAgent芯片验证平台！

    **你的角色：**
    你是专业的芯片验证AI助手，负责测试数字电路功能。

    **开始工作：**
    1. 先调用`RoleInfo`工具了解你的角色和当前任务
    2. 使用`CurrentTips`工具获取当前阶段的具体任务
    3. 用其他工具完成文件读写、搜索等操作

    **工作流程：**
    验证分为8个阶段：需求分析 → 功能理解 → 功能分析 → API设计 → 覆盖率模型 → 测试模板 → 执行测试 → 验证审查与总结

    **重要工具：**
    - `CurrentTips`: 获取当前阶段任务指导
    - `Check`: 检查阶段是否完成(会自动运行pytest等)
    - `Complete`: 完成当前阶段进入下一阶段
    - `ReadTextFile`: 读取文件(必须用这个，否则我不知道你读了什么)
    - 文件写入：你可以选择合适的工具

    **质量保证：**
    - 每个阶段完成后必须用`Check`工具验证
    - 如果测试发现bug，要详细分析原因和修复方案
    - 包括：问题描述、根本原因、影响范围、修复建议

    **核心原则：**
    - 按阶段有序推进
    - 注重代码和文档质量
    - 深入分析发现的问题
    - 生成实用、可维护的验证代码

    现在开始你的芯片验证工作！

stage:
  - name: requirement_analysis_and_planning
    desc: "需求分析与验证规划"
    task:
      - "第1步：读取{DUT}/README.md，理解用户的验证要求"
      - "第2步：确定验证目标 - 需要测试哪些功能？输入输出是什么？"
      - "第3步：识别风险点 - 哪些地方容易出错？边界条件有哪些？"
      - "第4步：制定验证计划 - 如何系统地测试所有功能？"
      - "第5步：写入验证规划文档到{OUT}/{DUT}_verification_needs_and_plan.md"
      - "注意：{DUT}中可能有隐藏bug，测试失败时请分析是否为设计缺陷"
    reference_files:
      - "{DUT}/README.md"
    checker:
          - name: markdown_file_check
            clss: "UnityChipCheckerMarkdownFileFormat"
            args:
              markdown_file_list: "{OUT}/{DUT}_verification_needs_and_plan.md"
              no_line_break: true

  - name: dut_function_understanding
    desc: "{DUT}功能理解"
    task:
      - "第1步：读取{DUT}/README.md，了解芯片基本信息"
      - "第2步：读取{DUT}/__init__.py，理解代码接口定义"
      - "第3步：分析输入输出端口 - 每个端口的作用是什么？"
      - "第4步：确定芯片类型 - 是时序电路(需要时钟)还是组合电路？"
      - "第5步：分析{DUT}的功能有哪几大类，大约有多少个功能点？"
      - "第6步：整理基本信息，写入{OUT}/{DUT}_basic_info.md"
      - "目标：为后续阶段提供清晰的芯片基础信息"
    reference_files:
      - "{DUT}/README.md"
      - "{DUT}/__init__.py"
    checker:
          - name: markdown_file_check
            clss: "UnityChipCheckerMarkdownFileFormat"
            args:
              markdown_file_list: "{OUT}/{DUT}_basic_info.md"
              no_line_break: true

  - name: functional_specification_analysis
    desc: "功能规格分析与测试点定义"
    task:
      - "目标：将芯片功能拆解成可测试的小块，为后续测试做准备"
      - "第1步：阅读{DUT}/下的所有相关文档，理解芯片完整待验证功能"
      - "第2步：对待验证功能点按功能模块分组，每组用<FG-名称>标记"
      - "第3步：每组内定义具体功能点，用<FC-名称>标记"
      - "第4步：每个功能点设计检测点，用<CK-名称>标记"
      - "第5步：写入{OUT}/{DUT}_functions_and_checks.md"
      - "重要：标签格式必须正确，这是后续自动化测试的基础"
      - "参考Guide_Doc/dut_functions_and_checks.md了解标准格式"
    reference_files:
      - "Guide_Doc/dut_functions_and_checks.md"
      - "{DUT}/*.md"
      - "{DUT}/__init__.py"
      - "{OUT}/{DUT}_basic_info.md"
      - "{OUT}/{DUT}_verification_needs_and_plan.md"
    output_files:
      - "{OUT}/{DUT}_functions_and_checks.md"
    stage:
      - name: functional_grouping
        desc: "功能分组与层次划分"
        task:
          - "基于{DUT}功能，将相关功能归类成组"
          - "为每组定义<FG-组名>标签，组名要有意义"
          - "创建文档框架，先完成分组部分"
          - "例如：加法器可分为<FG-BASIC>基础运算，<FG-OVERFLOW>溢出处理等，栈结构可以有<FG-PUSH>、<FG-POP>、<FG-POP-PUSH>等"
          - "注意：必须有<FG-API>分组"
        checker:
          - name: group_structure_check
            clss: "UnityChipCheckerLabelStructure"
            args:
              doc_file: "{OUT}/{DUT}_functions_and_checks.md"
              leaf_node: "FG"
      - name: function_point_definition
        desc: "具体功能点识别与定义"
        task:
          - "在每个功能分组内，定义具体的功能点"
          - "用<FC-功能名>标签标记每个功能"
          - "确保覆盖该组的所有功能"
          - "例如：基础运算组可包含<FC-ADD>加法，<FC-ZERO>零值处理等"
        checker:
          - name: function_point_check
            clss: "UnityChipCheckerLabelStructure"
            args:
              doc_file: "{OUT}/{DUT}_functions_and_checks.md"
              leaf_node: "FC"
      - name: check_point_design
        desc: "检测点设计与定义"
        task:
          - "为每个功能点设计具体的检测点"
          - "用<CK-检测名>标签标记，如<CK-BASIC>基本功能，<CK-BOUNDARY>边界条件"
          - "检测点要包含：正常情况、边界条件、异常情况"
          - "标签独立成行，与标题用空行分隔"
          - "完成完整的功能分析文档"
        checker:
          - name: check_point_check
            clss: "UnityChipCheckerLabelStructure"
            args:
              doc_file: "{OUT}/{DUT}_functions_and_checks.md"
              leaf_node: "CK"

  - name: testbench_infrastructure_design
    desc: "测试平台基础架构设计"
    task:
      - "目标：创建测试API接口，让后续测试更简单"
      - "第1步：分析{DUT}的底层接口和工作方式"
      - "第2步：设计create_dut()函数 - 负责创建和初始化芯片实例"
      - "第3步：配置时钟(时序电路需要，组合电路不需要)"
      - "第4步：实现dut fixture - 管理测试的完整生命周期"
      - "第5步：创建API函数 - 以'api_'开头，封装常用操作"
      - "第6步：写入{OUT}/tests/{DUT}_api.py"
      - "原则：让测试人员使用简单的API，而不是复杂的底层信号"
      - "参考Guide_Doc/dut_fixture_and_api.md了解标准写法"
    stage:
     - name: dut_creation_implementation
       desc: "DUT创建函数实现"
       task:
         - "在文件{OUT}/tests/{DUT}_api.py实现create_dut()函数，完成芯片的基础创建"
         - "在该函数中根据芯片类型配置时钟：时序电路用InitClock，组合电路不用"
         - "根据验证需要，确定是否需要在该函数中开启波形导出、代码行覆盖率等"
         - "确保创建函数能正常工作"
       checker:
         - name: dut_creation_check
           clss: "UnityChipCheckerDutCreation"
           args:
             target_file: "{OUT}/tests/{DUT}_api.py"
       reference_files:
         - "Guide_Doc/dut_fixture_and_api.md"
     - name: pytest_fixture_implementation
       desc: "pytest fixture实现"
       task:
         - "实现dut fixture，包含完整的生命周期管理"
         - "确保fixture能正确初始化和清理芯片"
       checker:
         - name: fixture_check
           clss: "UnityChipCheckerDutFixture"
           args:
             target_file: "{OUT}/tests/{DUT}_api.py"
       reference_files:
         - "Guide_Doc/dut_fixture_and_api.md"
     - name: basic_api_implementation
       desc: "基础API实现"
       task:
         - "请参考文档：Guide_Doc/dut_fixture_and_api.md创建API"
         - "至少实现1个基础API函数(以api_{DUT}_开头)"
         - "确保API函数能正确调用底层接口"
         - "每个API函数都必须要有对应的注释（位于函数__doc__）对功能进行详细描述，包括功能、输入参数、返回值等"
         - "需要根据{DUT}的功能进行API实现，如果可以，需要提供底层功能API和任务功能API"
         - "例如：对于ALU，需要实现底层功能 api_operate(data1, data2, operation), 然后基于其实现 api_add(data1, data2)等上层API接口"
       checker:
         - name: api_check
           clss: "UnityChipCheckerDutApi"
           args:
             api_prefix: "api_{DUT}_"
             target_file: "{OUT}/tests/{DUT}_api.py"
       reference_files:
         - "Guide_Doc/dut_fixture_and_api.md"

  - name: coverage_model_implementation
    desc: "功能覆盖率模型实现"
    task:
      - "目标：创建覆盖率统计系统，跟踪哪些功能已测试"
      - "第1步：读取功能分析文档{OUT}/{DUT}_functions_and_checks.md"
      - "第2步：为每个功能分组<FG-*>创建CovGroup覆盖组"
      - "第3步：为每个功能点<FC-*>添加watch_point监测点"
      - "第4步：为每个检测点<CK-*>实现检查函数(尽可能的用lambda函数)"
      - "第5步：实现get_coverage_groups(dut)主函数"
      - "第6步：结果写入{OUT}/tests/{DUT}_function_coverage_def.py"
      - "关键：检查函数要使用dut对象引用，不要用值(如dut而不是dut.a.value)"
      - "参考Guide_Doc/dut_function_coverage_def.md了解实现方法"
    stage:
      - name: coverage_group_creation
        desc: "功能覆盖组创建"
        task:
          - "为每个功能分组<FG-*>创建对应的CovGroup对象"
          - "实现get_coverage_groups(dut)基础框架"
          - "确保覆盖组可以正常创建和访问"
        checker:
          - name: coverage_group_check
            clss: "UnityChipCheckerCoverageGroup"
            args:
              test_dir: "{OUT}/tests"
              cov_file: "{OUT}/tests/{DUT}_function_coverage_def.py"
              doc_file: "{OUT}/{DUT}_functions_and_checks.md"
              check_types: "FG"
        reference_files:
          - "Guide_Doc/dut_function_coverage_def.md"

      - name: coverage_point_implementation
        desc: "覆盖率检查点实现"
        task:
          - "为每个功能点添加watch_point和检查函数"
          - "用lambda函数实现检查逻辑，传递引用参数(dut对象)"
          - "如果检查函数过于复杂，lambda函数可以用普通函数替代"
          - "如果多个检查函数有公共检查部分，也可以把公共部分实现为普通函数"
          - "完成完整的覆盖率定义，代码需要有注释，可读性强"
        checker:
          - name: coverage_implementation_check
            clss: "UnityChipCheckerCoverageGroup"
            args:
              test_dir: "{OUT}/tests"
              cov_file: "{OUT}/tests/{DUT}_function_coverage_def.py"
              doc_file: "{OUT}/{DUT}_functions_and_checks.md"
              check_types: ["FC","CK"]
        reference_files:
          - "Guide_Doc/dut_function_coverage_def.md"

  - name: basic_api_function_test
    desc: "基础API功能正确性测试"
    task:
      - "目标: 验证已实现的API函数功能是否正确，确保API接口质量"
      - "第1步：学习API测试规范 - 阅读Guide_Doc/dut_fixture_and_api.md，重点关注'API测试'部分"
      - "第2步：分析测试需求 - 查看{OUT}/{DUT}_functions_and_checks.md，了解需要测试的API功能点"
      - "第3步：创建API测试文件 - 在{OUT}/tests/目录下创建test_{DUT}_api_*.py测试文件"
      - "第4步：编写测试函数，每个测试函数需要："
      - "  - 函数名格式：test_<api_name>[_<test_scenario>]"
      - "  - 第一个参数：dut (pytest fixture)"
      - "  - 添加覆盖率标记：dut.fc_cover['FG-API'].mark_function('FC-API-NAME', your_test_function, ['CK-XXX'])"
      - "  - 包含详细的docstring：测试目标、流程、预期结果"
      - "  - 实现测试逻辑：设置输入、调用API、验证输出"
      - "第5步：测试内容包括："
      - "  - 基础功能测试：验证API核心功能正确性"
      - "  - 边界条件测试：测试边界值和特殊值处理"
      - "  - 错误处理测试：验证异常情况的处理机制"
      - "  - 参数验证测试：检查输入参数的合法性验证"
      - "第6步：验证测试结果 - 使用RunTestCases('{OUT}/tests/test_{DUT}_api[_name].py::your_test_function')运行并检查结果"
      - "要求：每个API函数至少有一个基础功能测试用例"
      - "完成所有API对应测试用例后，请用Check工具进行阶段检查"
    checker:
      - name: api_test_check
        clss: "UnityChipCheckerDutApiTest"
        args:
          api_prefix: "api_{DUT}_"
          target_file_api: "{OUT}/tests/{DUT}_api.py"
          target_file_tests: "{OUT}/tests/test_{DUT}_api*.py"
          doc_func_check: "{OUT}/{DUT}_functions_and_checks.md"
          doc_bug_analysis: "{OUT}/{DUT}_bug_analysis.md"
    reference_files:
      - "Guide_Doc/dut_fixture_and_api.md"

  - name: test_framework_scaffolding
    desc: "测试框架脚手架构建"
    task:
      - "目标：创建测试用例模板(因为该阶段API测试已完成，请排除API测试对应模板创建)，为实际测试做准备"
      - "第1步：分析功能文档{OUT}/{DUT}_functions_and_checks.md的所有测试点"
      - "第2步：根据功能点个数创建一个或者多个测试文件test_<名称>.py，文件名要有意义"
      - "第3步：在测试文件中按以下顺序创建测试函数："
      - "  - 1) 每个测试函数以test_开头，第一个参数为dut(pytest fixture)，可以根据需要添加其他参数"
      - "  - 2) 每个测试函数的最开始添加覆盖率标记：dut.fc_cover['FG-XXX'].mark_function('FC-YYY', test_func, ['CK-ZZZ'])"
      - "  - 3) 添加详细的TODO注释说明要测什么"
      - "  - 4) 最后添加assert False, 'Not implemented'防止意外通过"
      - "确保：每个功能点<FC-*>至少有一个测试用例"
      - "参考Guide_Doc/dut_test_template.md了解模板格式"
    checker:
      - name: template_check
        clss: "UnityChipCheckerTestTemplate"
        args:
          doc_func_check: "{OUT}/{DUT}_functions_and_checks.md"
          test_dir: "{OUT}/tests"
        extra_args:
          fail_msg: "测试模板创建不符合规范。检查：1)测试文件名以'test_'开头 2)正确导入API模块 3)包含覆盖率标记 4)有详细TODO注释 5)有防意外通过的断言。参考Guide_Doc/dut_test_template.md和examples了解正确格式。"
          pass_msg: "测试模板创建成功！测试结构规范，覆盖率标记完整。"
    reference_files:
      - "Guide_Doc/dut_test_template.md"

  - name: comprehensive_verification_execution
    desc: "全面验证执行与缺陷分析"
    task:
      - "目标：将测试模板填充为真实测试，发现并分析芯片bug"
      - "第1步：理解芯片完整功能和预期行为"
      - "第2步：将空的测试模板填充为可执行代码"
      - "第3步：使用API接口调用芯片功能，避免直接操作底层信号"
      - "第4步：设计充分的测试数据：典型值、边界值、特殊值"
      - "第5步：添加断言检查输出是否正确"
      - "第6步：每完成一个测试立即用RunTestCases('{OUT}/tests/test_target_file.py::target_case_to_run')检查运行结果"
      - "第7步：分析测试结果："
      - "  - 如果Pass：且所有测试过程正确符合预期，则继续完成下一个"
      - "  - 如果Fail但合理：可能发现了芯片bug，分析并记录到{OUT}/{DUT}_bug_analysis.md"
      - "  - 如果Fail不合理：修正测试逻辑"
      - "重要：测试失败时，优先怀疑是芯片设计问题，不要急于修改测试。可能在测试过程中发现覆盖率中的检查点有误，需进行相应调整"
      - "参考Guide_Doc/dut_test_case.md和dut_bug_analysis.md了解实现方法"
      - "上述过程中，可能发现之前步骤中需要修正，你需要进行相应的调整，例如完善api、功能覆盖等"
      - "注意：工具RunTestCases只是基于pytest运行测试用例，它并不进行类似Check那样的结果验证"
    checker:
      - name: test_check
        clss: "UnityChipCheckerTestCase"
        args:
          doc_func_check: "{OUT}/{DUT}_functions_and_checks.md"
          doc_bug_analysis: "{OUT}/{DUT}_bug_analysis.md"
          test_dir: "{OUT}/tests"
        extra_args:
          fail_msg: "测试实现不符合要求。检查：1)测试逻辑是否正确 2)是否使用API而非直接信号操作 3)测试数据是否充分 4)断言是否有效 5)覆盖率标记是否正确 6)发现的bug是否详细分析。参考Guide_Doc/dut_test_case.md和examples了解正确方法。"
          pass_msg: "测试实现成功！测试逻辑正确，验证全面，bug分析详尽。"
          max_try: -1
    reference_files:
      - "Guide_Doc/dut_test_case.md"
      - "Guide_Doc/dut_bug_analysis.md"

  - name: verification_review_and_summary
    desc: "验证审查与总结"
    task:
      - "目标：对测试过程进行回顾，提炼经验教训"
      - "第1步：整理测试过程中发现的问题，完善{OUT}/{DUT}_bug_analysis.md中对于的描述"
      - "第2步：总结测试经验，形成文档{OUT}/{DUT}_test_summary.md"
      - "第3步：回顾验证规划{OUT}/{DUT}_verification_needs_and_plan.md，检测是否满足验证需求"
      - "第4步：根据需要判断是否进行验证补充，或者调整验证规划"
      - "第5步：如果有必要可通过 GotoStage工具重新进入某个阶段进行补充验证"
    reference_files:
      - "Guide_Doc/dut_bug_analysis.md"
      - "Guide_Doc/dut_test_summary.md"
    output_files:
      - "{OUT}/{DUT}_test_summary.md"
