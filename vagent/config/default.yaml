
model_type: openai
openai:
  model_name: Qwen/Qwen3-32B
  openai_api_key: "EMPTY_API_KEY"
  openai_api_base: "http://127.0.0.1:8000/v1"
  model_kwargs:
    stop: ["."]

mission:
  name: "{DUT} 验证"
  prompt:
    system: >
      你是一名专业的 AI 软件工程和芯片验证专家，擅长利用软件测试的方法进行芯片验证。
      你的主要目标是完成`{DUT}`的验证工作，通过浏览所给工作目录，按照其中的规范文档，以及每个阶段的具体要求编写文档和代码。
      一个验证任务，由多个阶段组成，你需要通过工具`CurrentTips`获取当前阶段的任务提示。
      对于每个阶段，请按以下步骤有条理地进行：
      1.  理解需求：
      - 仔细阅读需求描述，充分理解问题本质。
      - 明确任务涉及核心组件，关联文档和期望行为，可通过工具`PathList`列出所有参考文件，或通过工具`SearchInGuidDoc`进行关键字检索。
      2.  按要求编写文档或者代码：
      - 使用可用工具创建或者编辑文档，在该过程中需要参考对应的文档和例子。
      - 不要创建多余的文档，且如果发现对应文件不可写，则说明该文件已经编写好了，你需要参考或者直接使用它。
      3.  调试与诊断：
      - 完成文档或者代码编写后，你需要调用工具`Check`检测你的成果是否符合基本要求。
      - 如果不符合要求，你需要工具返回的提示信息进行修正。
      - 如果检测通过，你可以继续进行下一阶段的任务。注意`Check`工具只是进行最基本的检测，完成检测出所有问题，后续阶段遇到问题可能需要修改上一个阶段的文件。
      5.  问题修复：
      - 如果Check不通过，你需要找到根因，开发精准、针对性的代码修改来修复问题。
      - 使用提供的文件编辑工具应用你的补丁，力求改动简洁、清晰。
      7.  总结你的工作：
      - 每个阶段任务完成时，用清晰简明的总结收尾并调用工具`Complete`。如果发现验证中的bug，需要说明 bug 的本质、你的验证逻辑，以及你验证其正确性和安全性的步骤。
      **指导原则：** 像高级软件工程师一样行动。优先保证正确性、安全性和高质量的测试驱动开发。

template: unity_test
un_write_dirs:
  - "{DUT}"
  - "Guide_Doc"
write_dirs:
  - "{OUT}"

embed:
  model: "Qwen/Qwen3-Embedding-8B"
  openai_base_url: http://10.156.154.242:8001/v1
  api_key: "EMPTY_API_KEY"
  dims: 4096

mcp_server:
  init_prompt: >
    首先请通过工具`RoleInfo`获取你的角色信息，然后基于工具：{TOOLS} 完成任务。
    执行任务时，通过CurrentTips获取任务提示。
    注意，你需要用ReadTextFile读取文本文件，不然我不知道你是否进行了读取操作，文件写操作你可以选择你擅长的工具；
    在完成每个阶段任务时，你需要用Check工具检测是否达标，它会自动运行程序，例如pytest等，然后返回检测结果。
    如果测试发现存在bug，需要进行充分详细的分析，最好能给出修复建议。

stage:
  - name: misson_understanding
    desc: "理解任务需求"
    task:
      - "阅读{DUT}/README.md，理解验证目标与任务。"
      - "你需要用工具Check、 Complete推进任务，用工具Status、Detail查看任务状态和细节。"
      - "如果需要任务回退，请使用GoToStage工具。"
      - "注意：{DUT}中可能存在多个bug，你需要在后续的任务中逐步发现和分析这些bug。因此当你写的测试用例不通过时，请确保是{DUT}存在bug导致的，而不是测试用例本身的问题。"
    checker:
      - name: do_not_need_check
        clss: NopChecker
    reference_files:
      - "{DUT}/README.md"
  - name: list_dut_functions_and_checks
    desc: "列出所有功能点与检测点"
    task:
      - "请阅读`当前目录`以及目录`{DUT}/`中的文档、代码和注释，理解待验证目标。"
      - "生成文档`{OUT}/{DUT}_functions_and_checks.md`，其中内容包括：{DUT}的所有功能，以及每个功能的检测点。一个功能点至少有1个以上的检测点。"
      - "请确保生成的文档内容完整、准确，并且格式清晰。具体格式要求参考文档：Guide_Doc/dut_functions_and_checks.md。"
      - "如果`{OUT}/{DUT}_functions_and_checks.md`已经存在，请检测是否需要完善其中的内容（已经存在的文件可能是模板，你需要根据模板中的注释中完成任务）。"
    checker:
      - name: doc_heck
        clss: "UnityChipCheckerFunctionsAndChecks"
        args:
          doc_file: "{OUT}/{DUT}_functions_and_checks.md"
          min_functions: 3
          min_checks: 3
        extra_args:
          fail_msg: "功能点与检测点检查失败，按错误提示进行修正，同时请检查生成的文档内容是否完整、准确、功能点个数是否达标等。注意：好好阅读参考文档，学习参考文档中<FG-*>、<FC-*>、<CK-*>的用法。可以参考 examples 中的例子。"
          pass_msg: "功能点与检测点检查成功，你做的很好！"
          max_try: 10
    reference_files:
      - "Guide_Doc/dut_functions_and_checks.md"
      - "{DUT}/*.md"
      - "{DUT}/__init__.py"
  - name: wrapper_dut_apis
    desc: "{DUT}接口封装"
    task:
      - "请阅读`当前目录`以及目录`{DUT}/`中的文档、代码和注释，理解待验证目标。"
      - "阅读你生成的文档`{OUT}/{DUT}_functions_and_checks.md`，理解{DUT}的功能点和检测点。"
      - "生成Python文件`{OUT}/tests/{DUT}_api.py`，其中内容包括：{DUT}的接口封装。所有接口函数以`api_`开头。"
      - "通过PyTest的fixture机制，实现创建dut的fixture。API和fixture的例子与格式请参考`Guide_Doc/dut_fixture_and_api.md`。"
      - "如果`{OUT}/tests/{DUT}_api.py`已经存在，请检测是否需要完善其中的内容（已经存在的文件可能是模板，你需要根据模板中的注释完成任务）。"
    checker:
      - name: api_check
        clss: "UnityChipCheckerDutApi"
        args:
          api_file: "{OUT}/tests/{DUT}_api.py"
          min_apis: 1
        extra_args:
          fail_msg: "接口封装检查失败，按错误提示进行修正，同时请检查生成的代码内容是否完整、准确。注意：好好阅读参考文档，api函数必须以`api_`开头。可以参考 examples 中的例子。"
          pass_msg: "接口封装检查成功，你做的很好！"
          max_try: 10
    reference_files:
      - "Guide_Doc/dut_fixture_and_api.md"
  - name: generate_function_coverage_defines
    desc: "生成功能覆盖分组"
    task:
      - "请阅读`当前目录`以及目录`{DUT}/`中的文档、代码和注释，理解待验证目标。"
      - "阅读你生成的文档`{OUT}/{DUT}_functions_and_checks.md`，理解{DUT}的功能点和检测点。"
      - "生成Python文件`{OUT}/tests/{DUT}_function_coverage_def.py`，其中内容包括：{DUT}的覆盖组。具体格式要求参考文档：Guide_Doc/dut_function_coverage_def.md。"
      - "如果`{OUT}/tests/{DUT}_function_coverage_def.py`已经存在，请检测是否需要完善其中的内容（已经存在的文件可能是模板，你需要根据模板中的注释中完成任务）。"
    checker:
      - name: cover_check
        clss: "UnityChipCheckerCoverGroup"
        args:
          test_path: "{OUT}/tests"
          group_file: "{OUT}/tests/{DUT}_function_coverage_def.py"
          min_groups: 1
        extra_args:
          fail_msg: "覆盖组检查失败，按错误提示进行修正，同时请检查生成的代码内容是否完整、准确。注意：好好阅读参考文档，且需要基于toffee库实现`get_coverage_groups(dut=None)->List[toffee.funcov.CovGroup]`函数。可以参考 examples 中的例子。"
          pass_msg: "覆盖组检查成功，你做的很好！"
          max_try: 10
    reference_files:
      - "Guide_Doc/dut_function_coverage_def.md"
  - name: generate_test_cases_and_run
    desc: "生成测试用例并运行"
    task:
      - "请阅读`当前目录`以及目录`{DUT}/`中的文档、代码和注释，理解待验证目标。"
      - "阅读你生成的文档`{OUT}/{DUT}_functions_and_checks.md`，理解{DUT}的功能点和检测点。"
      - "阅读你生成的文件`{OUT}/tests/{DUT}_api.py`，理解{DUT}的接口封装。"
      - "阅读你生成的文件`{OUT}/tests/{DUT}_function_coverage_def.py`，理解{DUT}的覆盖组。"
      - "根据功能点个数和分类，生成一个或者多个Python测试文件`{OUT}/tests/test_<name1>_<name2>.py`，其中内容包括：{DUT}的测试用例。具体格式要求参考文档：Guide_Doc/dut_test_case.md。"
      - "生成缺陷分析文件`{OUT}/{DUT}_bug_analysis.md`，其中内容包括：{DUT}的缺陷分析。具体格式要求参考文档：Guide_Doc/dut_bug_analysis.md。"
      - "如果文件已经存在，请检测是否需要完善其中的内容（已经存在的文件可能是模板，你需要根据模板中的注释中完成任务）。"
    checker:
      - name: test_check
        clss: "UnityChipCheckerTestCase"
        args:
          doc_func_check: "{OUT}/{DUT}_functions_and_checks.md"
          doc_bug_analysis: "{OUT}/{DUT}_bug_analysis.md"
          test_dir: "{OUT}/tests"
          min_tests: 1
        extra_args:
          fail_msg: "测试用例检查失败，按错误提示进行修正，同时请检查生成的代码内容是否完整、准确。如果是之前步骤不对，你可以回到之前的步骤进行修改或者重新生成。注意：好好阅读参考文档，且需要使用toffee.funcov.CovGroup进行功能覆盖率的统计。可以参考 examples 中的例子。"
          pass_msg: "测试用例检查成功，你做的很好！"
          max_try: -1
    reference_files:
      - "Guide_Doc/dut_test_case.md"
      - "Guide_Doc/dut_bug_analysis.md"
