
# 功能点描述与对应检测点描述

DUT即Design Under Test的缩写，请以下列格式进行DUT的功能点和对应检测点的描述：

## <DUT_NAME> 整体功能描述

在这里进行功能的简单描述，可以的话，进行简单举例说明。

### DUT功能分组A

<FG-TEST>

按照DUT功能的作用、对象等不同，可以进行功能分组，每个分组开始时，请用标签 `<FG-{name}>`进行分组标记。

### 具体功能1

<FC-FUNC1>

在这里对具体功能1进行描述。述描述中，每一个功能点都需要用标签 `<FC-{function-name}>`进行标记，`function-name`需要有确定意义，且与功能本身一致，且简约不重复。

**检测点：**
- <CK-NAME1>检测点1：功能1的检测点1描述
- <CK-NAME2>检测点2：功能1的检测点2描述

类似功能点，检测点也需要用标签`<CK-{check-point-name}>`进行标记。命名也需要有意义，且简约。在上述描述中，每一个功能点至少需要有一个以上的检测点与之对应。


以简单ALU为例，其“功能点描述与对应检测点描述”举例如下：

-----------------------------

# ALU 的功能点与检测点

## 端口与功能介绍

ALU 输入端口：
- a：第一个操作数，64 位
- b：第二个操作数，64 位
- cin：进位/借位输入，1 位
- op：功能选择，4 位。用于选择运算类型，包括加、减、乘、与、或、异或、非、左移、右移等

输出端口：
- out：运算结果，64 位
- cout：进位、借位或溢出标志，1 位

电路推进接口：step

具体说明：
- op = 0：加法，{cout, out} = a + b + cin
- op = 1：减法，out = a - b - cin，cout 表示是否发生借位
- op = 2：乘法，out = a × b，cout 表示高 64 位是否非零（溢出）
- op = 3：按位与，out = a & b
- op = 4：按位或，out = a | b
- op = 5：按位异或，out = a ^ b
- op = 6：按位非，out = ~a（对 a 逐位取反），b 此时无效
- op = 7：左移，out = a << (b & 0x3F)
- op = 8：右移，out = a >> (b & 0x3F)
- 其他 op 值：可扩展为除法、模运算等，未定义时 out 和 cout 输出为 0

注意事项：
- 所有运算均为 64 位宽度，超出部分由 cout 表示进位、借位或溢出。
- 对于移位操作，b 只取低 6 位作为移位量（保证最大移位 63 位）。
- 位非操作仅对 a 取反，b 可忽略。
- 若 op 超出定义范围，out 和 cout 输出为 0。

## ALU的功能说明与对应检查点

ALU 的主要功能点及其对应的检测点如下：

<FG-SIMPLE>

### 1. 加法功能 <FC-ADD>
实现 64 位加法运算，支持进位输入。

**检测点：**
- <CK-NORM> 普通加法（无进位输入）是否正确，例如 1 + 1 = 2
- <CK-OVERFLOW> a + b + cin 超出 64 位时，cout 是否正确反映进位
- <CK-CIN-NORM> 有 cin 输入时，加法结果是否正确
- <CK-CIN-OVERFLOW> 有 cin 输入且溢出时，cout 是否正确

---

### 2. 减法功能 <FC-SUB>
实现 64 位减法运算，支持借位输入。

**检测点：**
- <CK-NORM> 普通减法（无借位输入）是否正确，例如 5 - 3 = 2
- <CK-BORROW> a < b 或有 cin 输入时，cout 是否正确反映借位
- <CK-CIN-NORM> 有 cin 输入时，减法结果是否正确
- <CK-CIN-BORROW> 有 cin 输入且发生借位时，cout 是否正确

---

<FG-HARD>

### 3. 乘法功能 <FC-MUL>
实现 64 位乘法运算。

**检测点：**
- <CK-NORM> 普通乘法是否正确，例如 2 × 3 = 6
- <CK-OVERFLOW> 结果超出 64 位时，cout 是否正确反映高 64 位非零
- <CK-SIGNED> 有符号数乘法结果是否正确
- <CK-UNSIGNED> 无符号数乘法结果是否正确

---

### 4. 位操作功能 <FC-BITOP>
实现常见的位操作，包括与、或、异或、非、左移、右移。

**检测点：**
- <CK-AND> 按位与操作（a & b）是否正确
- <CK-OR> 按位或操作（a | b）是否正确
- <CK-XOR> 按位异或操作（a ^ b）是否正确
- <CK-NOT> 按位非操作（~a）是否正确，b 此时无效
- <CK-SHL> 左移操作（a << (b & 0x3F)）是否正确
- <CK-SHR> 右移操作（a >> (b & 0x3F)）是否正确

---
