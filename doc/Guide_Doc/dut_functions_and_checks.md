
# DUT 功能点与检测点描述指南

## 概述

本文档指导如何对DUT（Design Under Test，待测试设计）进行功能分析和检测点定义。通过系统化的功能分组、功能点识别和检测点设计，为后续的功能覆盖率测试奠定基础。

## 文档结构层次

### 层次关系
```
DUT整体功能
├── 功能分组 <FG-*>
│   ├── 功能点1 <FC-*>
│   │   ├── 检测点1 <CK-*>
│   │   ├── 检测点2 <CK-*>
│   │   └── ...
│   ├── 功能点2 <FC-*>
│   │   └── ...
│   └── ...
└── ...
```

### 标签系统
- **功能分组标签**：`<FG-{group-name}>` - 标识功能分组
- **功能点标签**：`<FC-{function-name}>` - 标识具体功能点 (也称为测试点 Test Point)
- **检测点标签**：`<CK-{check-point-name}>` - 标识具体检测点 (也称为Test Bin, 叫做“测试仓库”、“测试区间”或者“检查点”)

在“引用”检查点(Test Bin)时，通常用'/'拼接起来进行表示：

- FG-{group-name}/FC-{function-name}/CK-{check-point-name}

例如：
- FG-GROUP-A/FC-FUNCTION-A1/CK-CHECK-A1-1
- FG-GROUP-A/FC-FUNCTION-A1/CK-CHECK-A1-2
- FG-ARITHMETIC/FC-ADD/CK-BASIC


**重要提醒**：
- checker工具正是通过这些标签进行规范检测的，标签格式必须严格遵循规范。
- 检查点`<CK-{check-point-name}>` 之间需要尽可能的独立，不要出现对应功能交叉覆盖，以免后续出现bug导致覆盖率分析变得困难。

## 标准文档格式

### 文档模板

```markdown
# {DUT名称} 功能点与检测点描述

## DUT 整体功能描述

[这里描述DUT的整体功能，包括：]
- 主要用途和应用场景
- 输入输出接口说明
- 关键性能指标
- 工作原理概述

### 端口接口说明
- 输入端口：[端口名称、位宽、功能描述]
- 输出端口：[端口名称、位宽、功能描述]
- 控制信号：[控制信号说明]

## 功能分组与检测点

### 功能分组A

<FG-GROUP-A>

[功能分组的整体描述，说明该分组包含的功能范围]

#### 具体功能A1

<FC-FUNCTION-A1>

[详细描述功能A1的具体实现、输入输出关系、预期行为等]

**检测点：**
- <CK-CHECK-A1-1> 检测点1：[具体的检测条件和判断标准]
- <CK-CHECK-A1-2> 检测点2：[具体的检测条件和判断标准]
- ...

#### 具体功能A2

<FC-FUNCTION-A2>

[功能A2的描述...]

**检测点：**
- <CK-CHECK-A2-1> 检测点1：[检测条件...]
- ...

### 功能分组B

<FG-GROUP-B>

[继续下一个功能分组...]
```

### 标签放置规范

**✅ 正确的标签放置**
```markdown
### 具体功能1

<FC-FUNC1>

功能描述内容...
```

**❌ 错误的标签放置**
```markdown
### 具体功能1 <FC-FUNC1>
功能描述内容...
```

标签应独立成行，与标题之间用空行分隔，避免在Markdown预览时可见。

## 命名规范和最佳实践

### 命名原则

1. **简洁性**：名称应简短但具有明确含义
2. **一致性**：同类功能使用统一的命名模式
3. **可读性**：名称应易于理解，避免缩写歧义
4. **层次性**：体现功能的层次关系

### 推荐命名模式

#### 功能分组命名
```markdown
<FG-ARITHMETIC>    # 算术运算组
<FG-LOGIC>         # 逻辑运算组  
<FG-MEMORY>        # 内存操作组
<FG-CONTROL>       # 控制功能组
<FG-IO>            # 输入输出组
```

#### 功能点命名
```markdown
<FC-ADD>           # 加法功能
<FC-SUB>           # 减法功能
<FC-MUL>           # 乘法功能
<FC-CACHE-READ>    # 缓存读取
<FC-CACHE-WRITE>   # 缓存写入
<FC-BRANCH-PRED>   # 分支预测
```

#### 检测点命名
```markdown
<CK-NORM>          # 正常情况
<CK-OVERFLOW>      # 溢出情况
<CK-BOUNDARY>      # 边界条件
<CK-ERROR>         # 错误条件
<CK-ZERO>          # 零值处理
<CK-MAX>           # 最大值处理
<CK-MIN>           # 最小值处理
```

#### 必要分组

在所有功能点与检测点描述文档中，必须要有一下分组：

<FG-API> # 测试API分组，对DUT验证时需要用到的标准API

## 完整示例：ALU设计

### 设计规格

```markdown
# ALU 功能点与检测点描述

## DUT 整体功能描述

ALU（Arithmetic Logic Unit，算术逻辑单元）是CPU的核心组件，负责执行各种算术和逻辑运算。本ALU支持64位数据处理，提供多种运算模式。

### 端口接口说明

**输入端口：**
- `a`：第一个操作数，64位无符号数
- `b`：第二个操作数，64位无符号数  
- `cin`：进位/借位输入，1位
- `op`：功能选择信号，4位，用于选择运算类型

**输出端口：**
- `out`：运算结果，64位
- `cout`：进位、借位或溢出标志，1位

**控制接口：**
- `enable`：使能信号，1位
- `reset`：复位信号，1位，高电平有效

### 运算模式定义

| op值 | 运算类型 | 运算公式 | cout含义 |
|------|----------|----------|----------|
| 0    | 加法     | {cout,out} = a + b + cin | 进位输出 |
| 1    | 减法     | out = a - b - cin | 借位标志 |
| 2    | 乘法     | out = a × b | 溢出标志 |
| 3    | 按位与   | out = a & b | 固定为0 |
| 4    | 按位或   | out = a \| b | 固定为0 |
| 5    | 按位异或 | out = a ^ b | 固定为0 |
| 6    | 按位非   | out = ~a | 固定为0 |
| 7    | 左移     | out = a << (b & 0x3F) | 固定为0 |
| 8    | 右移     | out = a >> (b & 0x3F) | 固定为0 |
| 其他 | 保留     | out = 0, cout = 0 | 无定义 |

## 功能分组与检测点


### DUT测试API

<FG-API>

#### 通用operation功能

<FC-OPERATION>

提供DUT支持的各种运算操作接口，涵盖所有op操作码对应的运算类型。这些操作是DUT的核心功能实现。

**检测点：**
- <CK-ADD> 加法操作：验证op=0时的加法运算功能，{cout,out} = a + b + cin
- <CK-SUB> 减法操作：验证op=1时的减法运算功能，out = a - b - cin  
- <CK-MUL> 乘法操作：验证op=2时的乘法运算功能，out = a × b
- <CK-AND> 按位与操作：验证op=3时的按位与运算功能，out = a & b
- <CK-OR> 按位或操作：验证op=4时的按位或运算功能，out = a | b
- <CK-XOR> 按位异或操作：验证op=5时的按位异或运算功能，out = a ^ b
- <CK-NOT> 按位非操作：验证op=6时的按位非运算功能，out = ~a
- <CK-SHL> 左移操作：验证op=7时的左移运算功能，out = a << (b & 0x3F)
- <CK-SHR> 右移操作：验证op=8时的右移运算功能，out = a >> (b & 0x3F)
- <CK-INVALID> 无效操作码：验证op值超出定义范围时的处理，out = 0


<FG-ARITHMETIC>

### 算术运算功能分组
包含基本的算术运算功能：加法、减法、乘法等。

#### 加法功能

<FC-ADD>

实现64位加法运算，支持进位输入。运算公式：{cout, out} = a + b + cin

**检测点：**
- <CK-BASIC> 基本加法：验证无进位输入时的基本加法运算，如1+1=2
- <CK-CARRY-IN> 进位输入：验证有进位输入时的加法运算，如1+1+1=3  
- <CK-OVERFLOW> 加法溢出：验证结果超出64位时进位输出正确性
- <CK-ZERO> 零值运算：验证操作数为0时的运算正确性，如0+0=0
- <CK-BOUNDARY> 边界条件：验证最大值、最小值等边界条件下的运算

#### 减法功能

<FC-SUB>

实现64位减法运算，支持借位输入。运算公式：out = a - b - cin

**检测点：**
- <CK-BASIC> 基本减法：验证无借位输入时的基本减法运算，如5-3=2
- <CK-BORROW-IN> 借位输入：验证有借位输入时的减法运算
- <CK-UNDERFLOW> 减法下溢：验证a<b时借位输出的正确性
- <CK-ZERO-RESULT> 零结果：验证a=b时结果为0的情况
- <CK-SELF-SUB> 自减运算：验证a-a=0的特殊情况

#### 乘法功能

<FC-MUL>

实现64位乘法运算。当结果超过64位时，cout标识溢出。

**检测点：**
- <CK-BASIC> 基本乘法：验证基本的乘法运算，如2×3=6
- <CK-OVERFLOW> 乘法溢出：验证结果超出64位时溢出标志正确性
- <CK-ZERO-FACTOR> 零乘数：验证操作数为0时结果为0
- <CK-ONE-FACTOR> 单位乘数：验证乘以1时结果不变
- <CK-LARGE-NUM> 大数乘法：验证大数相乘的正确性

<FG-LOGIC>

### 逻辑运算功能分组
包含各种位操作和逻辑运算功能。

#### 位运算功能

<FC-BITWISE>

实现基本的位操作：与、或、异或、非等。

**检测点：**
- <CK-AND> 按位与：验证a&b运算的正确性
- <CK-OR> 按位或：验证a|b运算的正确性
- <CK-XOR> 按位异或：验证a^b运算的正确性
- <CK-NOT> 按位非：验证~a运算的正确性（b无效）
- <CK-ALL-ONES> 全1操作：验证操作数全为1时的运算结果
- <CK-ALL-ZEROS> 全0操作：验证操作数全为0时的运算结果

#### 移位功能

<FC-SHIFT>

实现左移和右移运算，移位量取b的低6位。

**检测点：**
- <CK-SHL-BASIC> 基本左移：验证基本左移运算的正确性
- <CK-SHR-BASIC> 基本右移：验证基本右移运算的正确性
- <CK-SHIFT-ZERO> 零位移：验证移位量为0时结果不变
- <CK-SHIFT-MAX> 最大位移：验证移位63位时的结果
- <CK-SHIFT-OVERFLOW> 移位溢出：验证移位量≥64时的行为

<FG-CONTROL>

### 控制功能分组
包含控制信号处理和特殊状态管理。

#### 使能控制

<FC-ENABLE>

控制ALU的使能状态，使能信号无效时输出保持。

**检测点：**
- <CK-ENABLE-HIGH> 使能有效：验证使能信号有效时正常运算
- <CK-ENABLE-LOW> 使能无效：验证使能信号无效时输出保持不变
- <CK-ENABLE-TOGGLE> 使能切换：验证使能信号切换时的行为

#### 复位功能

<FC-RESET>

处理复位信号，复位时所有输出清零。

**检测点：**
- <CK-RESET-SYNC> 同步复位：验证同步复位的正确性
- <CK-RESET-ASYNC> 异步复位：验证异步复位的正确性（如果支持）
- <CK-RESET-RELEASE> 复位释放：验证复位释放后的正常工作

#### 未定义操作

<FC-UNDEFINED>

处理未定义的操作码，确保输出可预测。

**检测点：**
- <CK-OP-INVALID> 无效操作码：验证op值超出定义范围时输出为0
- <CK-OP-RESERVED> 保留操作码：验证保留操作码的处理
```

## 质量检查清单

### 完整性检查
- [ ] 每个功能分组至少包含一个功能点
- [ ] 每个功能点至少包含一个检测点  
- [ ] 所有标签格式正确且唯一
- [ ] 功能描述清晰完整

### 一致性检查
- [ ] 命名风格统一
- [ ] 标签放置位置正确
- [ ] 检测点覆盖主要场景
- [ ] 功能点之间无重复或遗漏

### 可测试性检查
- [ ] 检测点可以通过测试用例验证
- [ ] 检测条件明确可判断
- [ ] 边界条件和异常情况已考虑
- [ ] 测试数据可以设计
