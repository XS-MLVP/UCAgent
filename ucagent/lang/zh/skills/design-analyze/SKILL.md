---
name: design-analyze
description: 芯片设计文档分析与功能解析技能。系统化阅读芯片设计文档(README.md、__init__.py、.v/.sv文件),梳理接口、解析功能点,生成验证计划。当用户要求"分析DUT设计"、"理解芯片功能"、"梳理接口定义"、"生成功能分析文档"、"设计验证计划"或提到"设计文档分析"、"功能点识别"、"<FG-*>/<FC-*>/<CK-*>标签"时使用。
---

# 芯片设计文档分析与功能解析技能

## 分析工作流程

### 第一步:文档定位与收集

**目标**: 找到所有相关的设计文档和代码文件

**操作步骤**:
1. 使用 `list_dir` 列出 DUT 目录下的所有文件
2. 识别关键文档:
   - `README.md` - 设计概述和使用说明
   - `__init__.py` - 接口定义和端口声明
   - `*.v` / `*.sv` - Verilog/SystemVerilog 源码
   - `*.scala` / 其他高级语言源码
   - 其他说明文档 (如 SPEC.md, DOC.md 等)

**检查清单**:
- [ ] 是否找到了 README.md?
- [ ] 是否找到了接口定义文件?
- [ ] 是否有额外的规格说明文档?
- [ ] 是否有源码文件可以参考?

### 第二步:宏观功能理解

**目标**: 理解芯片的整体功能和用途

**阅读 README.md 时关注**:
1. **芯片类型与用途**
   - 这是什么类型的电路?(ALU、存储器、控制器、总线等)
   - 解决什么问题?
   - 应用场景是什么?

2. **基本特性**
   - 是组合电路还是时序电路?
   - 数据位宽是多少?
   - 是否有时钟和复位信号?
   - 是否有特殊的时序要求?

3. **功能概述**
   - 主要功能有哪些?
   - 支持哪些操作模式?
   - 有哪些配置选项?

**记录模板**:
```
## 芯片基本信息
- 名称: [DUT名称]
- 类型: [组合电路/时序电路]
- 功能: [一句话描述]
- 应用场景: [具体场景]
- 位宽: [数据位宽]
- 时钟: [是否需要时钟]
```

### 第三步:接口分析

**目标**: 详细理解所有输入输出端口

**阅读 __init__.py 或 接口定义时关注**:
1. **端口分类**
   - 输入端口 (Input Ports)
   - 输出端口 (Output Ports)
   - 双向端口 (InOut Ports, 如有)
   - 控制信号 (如 clk, rst, enable 等)

2. **端口详情**
   - 端口名称和位宽
   - 端口功能和用途
   - 有效电平 (高有效/低有效)
   - 是否有默认值

3. **接口分组**
   - 是否可以按功能分组?
   - 哪些信号是一组总线?
   - 是否有标准接口协议?(如 AXI, APB 等)

4. **接口逻辑**
   - 输出端口与输入端口的关系

**记录模板**:
```
## 接口定义

### 输入端口
| 端口名 | 位宽 | 功能描述 | 有效电平 | 备注 |
|--------|------|----------|----------|------|
| ...    | ...  | ...      | ...      | ...  |

### 输出端口
| 端口名 | 位宽 | 功能描述 | 有效电平 | 备注 |
|--------|------|----------|----------|------|
| ...    | ...  | ...      | ...      | ...  |

### 控制信号
| 信号名 | 功能描述 | 备注 |
|--------|----------|------|
| clk    | 时钟信号 | 上升沿触发 |
| rst    | 复位信号 | 低有效异步复位 |
```

### 第四步:功能点识别与分解

**目标**: 将芯片功能拆解成可测试的功能点

**分析方法**:
1. **功能分组 (FG - Function Group)**
   - 按照功能领域划分大类
   - 每组用 `<FG-名称>` 标记
   - 必须包含 `<FG-API>` 分组
   - 示例分组:
     - `<FG-BASIC>` - 基础运算功能
     - `<FG-BOUNDARY>` - 边界条件处理
     - `<FG-ERROR>` - 错误处理
     - `<FG-API>` - API 接口测试

2. **功能点定义 (FC - Function Check)**
   - 在每组内定义具体功能
   - 每个功能用 `<FC-名称>` 标记
   - 功能点要具体、可测试
   - 示例:
     - `<FC-ADD>` - 加法运算
     - `<FC-OVERFLOW>` - 溢出检测

3. **检测点设计 (CK - Check Point)**
   - 为每个功能点设计验证点
   - 每个检测点用 `<CK-名称>` 标记
   - 包含正常情况、边界条件、异常情况
   - 示例:
     - `<CK-BASIC>` - 基本功能正确性
     - `<CK-BOUNDARY>` - 边界值测试
     - `<CK-ZERO>` - 零值处理

**分解策略**:
- **自顶向下**: 从整体功能到具体实现
- **全面覆盖**: 不遗漏任何功能点
- **细粒度**: 功能点足够小,便于测试
- **可测性**: 每个检测点都能通过测试进行验证

### 第五步:风险点与边界条件识别

**目标**: 找出容易出错的地方和需要特别测试的场景

**关注领域**:
1. **数值边界**
   - 最大值/最小值
   - 零值
   - 溢出/下溢
   - 符号位转换

2. **时序边界**
   - 复位时刻
   - 状态转换边界
   - 流水线边界
   - 连续操作

3. **特殊情况**
   - 非法输入
   - 冲突操作
   - 资源竞争
   - 异常状态

4. **协议要求**
   - 握手时序
   - 建立保持时间
   - 总线仲裁
   - 优先级处理

### 第六步:验证策略制定

**目标**: 规划如何系统地测试所有功能

**策略要素**:
1. **测试优先级**
   - 核心功能 (高优先级)
   - 边界条件 (高优先级)
   - 特殊场景 (中优先级)
   - 性能测试 (低优先级)

2. **测试方法**
   - 定向测试 (针对特定功能)
   - 随机测试 (覆盖参数空间)
   - 压力测试 (极限场景)
   - 回归测试 (验证修改)

3. **覆盖目标**
   - 功能覆盖率目标
   - 代码行覆盖率目标
   - 关键路径覆盖

## 输出物标准

完成分析后,应产生以下文档:

### 1. 基本信息文档 (`{DUT}_basic_info.md`)
```markdown
# {DUT} 基本信息

## 芯片概述
[一段话描述芯片功能和用途]

## 电路类型
- 类型: [组合电路/时序电路]
- 是否需要时钟: [是/否]

## 接口概览
- 输入端口数: X
- 输出端口数: Y
- 总位宽: Z bits

## 主要功能
1. 功能1
2. 功能2
...

## 功能分类
[列出主要的功能分类,大约N个功能点]
```

### 2. 功能与检测点文档 (`{DUT}_functions_and_checks.md`)
```markdown
# {DUT} 功能分析与检测点定义

<FG-API>
## API 接口测试

<FC-API-XXX>
### API 功能点 XXX

<CK-BASIC>
#### 基本功能
[描述]

<CK-BOUNDARY>
#### 边界条件
[描述]

<FG-BASIC>
## 基础功能

<FC-OPERATION1>
### 操作1

<CK-NORMAL>
#### 正常情况
[描述]

<CK-EDGE>
#### 边界情况
[描述]
```

### 3. 验证规划文档 (`{DUT}_verification_needs_and_plan.md`)
```markdown
# {DUT} 验证需求与计划

## 验证目标
[明确要验证什么]

## 功能需求
[列出需要验证的所有功能]

## 风险识别
[容易出错的地方]

## 验证策略
[如何系统地测试]

## 里程碑
[验证的阶段划分]
```

## 最佳实践

### DO - 应该做的

✅ **使用 ReadTextFile 读取文件** - 让系统知道你读了哪些文件
✅ **按顺序阅读** - README → 接口定义 → 详细文档 → 源码
✅ **记录关键信息** - 及时写入对应的文档文件
✅ **使用标准标签** - 严格使用 `<FG-*>`, `<FC-*>`, `<CK-*>` 格式
✅ **保持层次清晰** - 分组 → 功能点 → 检测点
✅ **考虑验证视角** - 思考如何测试每个功能
✅ **识别隐患** - 主动寻找可能的 bug 和边界问题

### DON'T - 不应该做的

❌ **跳过文档直接看代码** - 可能遗漏设计意图
❌ **遗漏边界条件** - 边界是 bug 的高发区
❌ **功能点过粗** - 难以针对性测试
❌ **标签格式错误** - 影响后续自动化
❌ **忽略特殊情况** - 异常处理同样重要
❌ **孤立地理解功能** - 要考虑功能间的交互

## 常见陷阱与解决方案

### 陷阱 1: 文档不完整或不清晰
**症状**: README 信息太少,接口说明模糊
**解决**:
- 结合源码理解设计意图
- 使用 `grep_search` 搜索关键信号的使用方式
- 从测试角度推断功能行为
- 在分析文档中标注不确定的部分

### 陷阱 2: 功能点划分不当
**症状**: 功能点太大或太小,难以测试
**解决**:
- 一个功能点对应一个明确的行为
- 如果一个测试用例能验证,则粒度合适
- 复杂功能拆分成多个子功能点
- 简单功能可以合并到同一功能点

### 陷阱 3: 遗漏隐含功能
**症状**: 只关注显式说明的功能,忽略隐含行为
**解决**:
- 思考"如果我是用户,还会关心什么?"
- 检查错误处理、复位行为、默认状态
- 考虑多操作的组合效果
- 阅读源码发现文档未提及的逻辑

### 陷阱 4: 标签使用混乱
**症状**: 标签格式不统一,层次关系不清
**解决**:
- 遵循模板: FG(分组) → FC(功能) → CK(检测点)
- 标签独立成行,与内容用空行分隔
- 使用有意义的名称,避免 FG-1, FG-2 这种
- 参考 `Guide_Doc/dut_functions_and_checks.md`

## 技能检查清单

完成分析后,检查是否达到以下标准:

**文档完整性**:
- [ ] 已创建 `{DUT}_basic_info.md`
- [ ] 已创建 `{DUT}_functions_and_checks.md`
- [ ] 已创建 `{DUT}_verification_needs_and_plan.md`
- [ ] 所有文档使用中文编写

**分析深度**:
- [ ] 理解了芯片的整体功能和用途
- [ ] 识别了所有输入输出端口及其含义
- [ ] 确定了电路类型(组合/时序)
- [ ] 列出了所有主要功能模块
- [ ] 识别了边界条件和风险点

**功能拆解质量**:
- [ ] 定义了至少 3 个功能分组 (包含 FG-API)
- [ ] 每个分组包含具体的功能点
- [ ] 每个功能点定义了检测点
- [ ] 标签格式正确且层次清晰
- [ ] 覆盖了所有功能和边界情况

**验证规划合理性**:
- [ ] 明确了验证目标
- [ ] 识别了测试重点和优先级
- [ ] 制定了系统的验证策略
- [ ] 考虑了潜在的设计缺陷